# A. Дек

**ID успешной посылки**: 64394489

## Структура

`deck.js` -- реализация дека

`solution.js` -- отвечает за инстанцирование дека, корректную итерацию по командам и отображение результат

`index.js` -- отвечает за приём данных из `stdin`

## Принцип работы
Я реализовал дек на кольцевом буфере.
Под капотом дека инициируется массив фиксированной длины.

Как и в случае очереди на кольцевом буфере, принцип заключается в том, что есть два указателя -- начало (`front`) и конец (`back`).
Но т.к. это дек, главное отличие в том, что эти указатели могут как увеличиваться, так и уменьшаться в зависимости от операции. 
Изначально, оба указателя указывают на первый индекс массива.

При добавлении элементов (`push_front()` и `push_back()`), индексы идут в противоположные стороны.
При `push_front()` индекс `front` уменьшается, а при `push_back()` индекс `back` увеличивается.
Чтобы избежать выходы индексов за границы массива, используется внутренний метод `_handleIndexOverflow()`.
Его логика схожа с [Array.prototype.at](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at):
если значение меньше *0*, то оно возвращает индекс последнего элемента массива, а если значение больше последнего индекса -- возвращает *0*.

Естественно, при каждом добавлении в дек происходит проверка, не заполнен ли массив

### Иллюстрация алгоритма добавления в начало дека

1. `new Deck(5)`

| 0   | 1   | 2   | 3   | 4   |
|-----|-----|-----|-----|-----|
| x   | x   | x   | x   | x   |

2. `push_front('a')`

| 0     | 1   | 2   | 3   | 4   |
|-------|-----|-----|-----|-----|
| `'a'` | x   | x   | x   | x   |

3. `push_front('b')`

| 0   | 1   | 2   | 3   | 4     |
|-----|-----|-----|-----|-------|
| 'a' | x   | x   | x   | `'b'` |

4. `push_front('c')`

| 0   | 1   | 2   | 3     | 4   |
|-----|-----|-----|-------|-----|
| 'a' | x   | x   | `'c'` | 'b' |


### Иллюстрация добавления в конец дека

1. `new Deck(5)`

| 0   | 1   | 2   | 3   | 4   |
|-----|-----|-----|-----|-----|
| x   | x   | x   | x   | x   |

2. `push_back('a')`

| 0     | 1   | 2   | 3   | 4   |
|-------|-----|-----|-----|-----|
| `'a'` | x   | x   | x   | x   |

3. `push_back('b')`

| 0   | 1     | 2   | 3   | 4   |
|-----|-------|-----|-----|-----|
| 'a' | `'b'` | x   | x   | x   |

4. `push_back('c')`

| 0   | 1   | 2     | 3   | 4   |
|-----|-----|-------|-----|-----|
| 'a' | 'b' | `'c'` | x   | x   |


Извлечение происходит в обратном порядке: "голова" идёт вправо, а "конец" -- влево.

## Доказательство корректности 
Реализация дека на кольцевом буфере позволяет проводить операции за константное время 

## Временная сложность 
Добавление и извлечение элементов происходит за *O(1)*:
дек всегда фиксированного размера, а элементы удаляются и добавляются по индексам.

Но т.к. в качестве входных данных мы получаем массив команд для дека(`['push_back 844', 'pop_back']`) временная сложность всего решения составляет *O(n)*.


## Пространственная сложность
*O(n)*